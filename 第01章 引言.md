# 第01章 引言

---

## 0. DBMS DB DBS

- **数据库管理系统**（DataBase-Management System，DBMS）由一个互相关联的数据集合和一组用以访问这些数据的程序组成。这个数据集合通常称作**数据库**，DBMS的主要目标是要提供一种可以*方便、高效地*存取数据库信息的途径。用户通过DBMS访问数据库（DB）中的数据。
- **数据库系统**（DataBase System）是一个统称，包括数据库、数据库管理系统、数据库管理人员等的统称，是最大的范畴。
- DBS包含DB和DBMS

---

## 1. 数据库系统的目标

**文件处理系统**的主要弊端

- **数据的冗余与不一致**：存储开销增大可能导致统一数据不同副本不一致。
- **数据访问困难**：满足特定需求的难度大。
- **数据孤立**：数据分散在不同文件中，不同文件格式可能不一致。
- **完整性问题**：数据库中数据值必须满足某些特定的**一致性约束**。开发者在不同应用程序中加入适当的代码来强制系统中的这些约束。但是，当加入新的约束，尤其是涉及到不同文件的多个数据时，很难通过修改程序来实现这些约束。
- **原子性问题**：传统文件处理系统很难做到一个事务的所有操作要么不间断地全部被执行，要么一个也不执行。
- **并发访问异常**：数据可能被多个不同的应用程序同时访问，这些程序间又没有相互协调，很难进行管理。
- **安全性问题**：文件处理系统很难实现“并非所有用户都可以访问数据库系统的所有数据”的安全性约束。

---

## 2. 数据视图

### 2.1 数据抽象

```sql
type instructor = record
		ID: char(5);
		name: char(20);
		dept_name: char(20);
		salary: numeric(8, 2);
		end;
```

以上代码定义了一个四个字段的新纪录instructor，对一个大学，可能包含以下记录类型：

- *department*，包含字段*dept_name*、*building*和*budget*。
- *course*，包含字段*course_id*、*title*、*dept_name*和*credits*。
- *student*，包含字段*ID*、*name*、*dept_name*和*tot_cred*。

系统开发人员通过三个层次上的抽象来对用户屏蔽复杂性：

- **物理层**：描述数据实际上是*怎样*存储的，详细描述复杂的底层数据结构。
- **逻辑层**：比物理层层次稍高的抽象，描述数据库中存储*什么*数据及这些数据间存在什么关系。虽然逻辑层的简单结构可能涉及复杂的物理层结构，但逻辑层用户不必知道这样的复杂性，这被称作**物理数据独立性**。
- **视图层**：最高层次的抽象，只描述整个数据库的某个部分。系统可以为同一数据库提供多个视图，使只需访问数据库一部分的用户交互更加简单。

在**物理层**，一个*instructor*、*department*或*student*记录可能被描述为连续存储位置组成的存储块，**数据库管理员**可能需要了解数据物理组织的某些细节；在**逻辑层**，每个这样的记录通过类型定义进行描述，同时还要定义这些记录类型的相互关系，**程序设计人员**在这个抽象层次上使用某种程序设计语言进行工作，**数据库管理员**常常在这个抽象层次上工作；在**视图层**，计算机用户看见的是为其屏蔽了数据类型细节的一组应用程序，视图层上定义了数据库的多个视图，数据库用户看到的是这些视图，除了屏蔽数据库逻辑层的细节以外，视图还提供了防止用户访问数据库某些部分的啊安全机制。

### 2.2 实例和模式

1. **实例**（instance）：特定时刻存储在数据库中的信息的集合。
2. **模式**（schema）：数据库的总体设计。
- 物理模式：在物理层描述数据库的设计。
- 逻辑模式：在逻辑层描述数据库的设计。

数据库在视图层也可以有几种模式，有时称为子模式。

物理模式*隐藏*在逻辑模式下，并且通常可以在应用程序丝毫不受影响的情况下被轻易地更改。应用程序如果不依赖于物理模式，它们就被称为具有**物理数据独立性**。

### 2.3 数据模型

数据库结构的*基础*是**数据模型**。数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。它提供了一种描述物理层、逻辑层以及视图层数据库设计的方式。

- **关系模型**（relational model）：用表的集合表示数据和数据间的联系。是使用最广泛的数据模型。
- **实体 - 联系模型**（entity-relationship model）：E-R数据模型基于对现实世界的一种认识：现实世界由一组称作实体的基本对象以及这些对象间的联系构成。被广泛用于数据库设计。
- **基于对象的数据模型**（object-based data model）：可以看成是E-R模型增加了封装、方法（函数）和对象标识等概念后的扩展。
- **半结构化数据模型**（semistructured data model）：允许相同类型的数据项含有不同属性集的数据定义。可扩展标记语言（eXtensible Markup Language，XML）被广泛地用来表示半结构化数据。

---

## 3. 数据库语言

### 3.1 数据操纵语言

**数据操纵语言**（Data-Manipulation Language，DML）使得用户可以访问或操纵那些按照某种适当的数据模型组织起来的数据，有以下访问类型：

- 检索信息
- 插入新信息
- 删除信息
- 修改信息

通常有两类基本得数据操纵语言：

- **过程化DML**（procedural DML）：要求用户指定需要什么数据以及如何获得这些数据。
- **声明式DML**（declarative DML）（也被称为非过程化DML）：只要求用户需要什么数据，而不指明如何获得该数据。

**查询**（query）是要求对信息进行检索的语句。DML中涉及信息检索的部分称作**查询语言**（query language）。实践中常把*查询语言*和*DML*作为同义词使用，但是从技术上来说这不正确。

### 3.2 数据定义语言

数据库模式是通过一系列定义来说明的，这些定义由一种称作**数据定义语言**（Data-Definition Language，DDL）的特殊语言来表达。DDL也可用于定于数据的其他特征。

数据库系统所使用的存储结构和访问方式是通过一系列特殊的DDL语句来说明的，这种特殊的DDL被称作**数据存储与定义**（data storage and definition）语言。

存储在数据库中的数据值必须满足某些**一致性约束**（consistency constraint），例如银行账户余额不能为负数。DDL语言提供了指定这种约束的工具。每当数据库更新时，数据库系统都会检查这些约束。通常，约束可以是关于数据库的任意谓词。然而，如果要测试任意谓词，可能代价比较高。因此，数据库系统实现可以以最小代价测试的完整性约束。

- **域约束**（domain constraint）：每个属性都必须对应于一个所有可能的取值构成的域（例如整数型、字符型、日期/时间型）。声明一种属性属于某种具体的域就相当于约束它可以取的值。域约束是完整性约束的最基本形式。
- **参照完整性**（referential integrity）：一个关系中给定属性集上的取值也在另一关系的某一属性集的取值中出现。例如，每门课程所列出的系必须是实际存在的系，即一个*course*记录中的*dept_name*值必须出现在*department*关系中某个记录*dept_name*属性中。
- **断言**（assertion）：一个断言就是数据库需要时刻满足的某一条件。域约束和参照完整性是断言的特殊形式。
- **授权**（authorization）：不同的用户在数据库中的不同数据值上允许不同的访问类型。最常见的是**读权限**（read authorization），允许读取，不能修改；**插入权限**（insert authorization），允许插入新数据，不能修改已有数据；**更新权限**（update authorization），允许修改，但不能删除；**删除权限**（delete authorization），允许删除。可以赋予用户*所有*权限，也可以赋予*部分*或者*不赋予*权限。

---

## 4. 关系数据库

### 4.1 表

a) instructor表
|  ID   |    name    | dept_name  | salary |
| :---: | :--------: | :--------: | :----: |
| 22222 |  Einstein  |  Physics   | 95000  |
| 12121 |     Wu     |  Finance   | 90000  |
| 32343 |  El Said   |  History   | 60000  |
| 45565 |    Katz    | Comp. Sci. | 75000  |
| 98345 |    Kim     | Elec. Eng. | 80000  |
| 76766 |   Crick    |  Biology   | 72000  |
| 10101 | Srinivasan | Comp. Sci. | 65000  |
| 58583 | Califieri  |  History   | 62000  |
| 83821 |   Brandt   | Comp. Sci. | 92000  |
| 15151 |   Mozart   |   Music    | 40000  |
| 33456 |    Gold    |  Physics   | 87000  |
| 76543 |   Singh    |  Finance   | 80000  |


b) department表
| dept_name  | building | budget |
| :--------: | :------: | :----: |
| Comp. Sci. |  Taylor  | 100000 |
|  Biology   |  Watson  | 90000  |
| Elec. Eng. |  Taylor  | 85000  |
|   Music    | Packard  | 80000  |
|  Finance   | Painter  | 120000 |
|  History   | Painter  | 50000  |
|  Physics   |  Watson  | 70000  |



### 4.2 数据操纵语言

```sql
-- 找出历史系所有教员的名字
select instructor.name
from instructor
where instructor.dept_name = 'History';
```

输出结果为两行，一个是El Said，另一个是Califieri。

```sql
/*
查找涉及来自不止一个表的信息
找出经费预算大于95000美元的系相关联的所有教员的ID和系名
*/
select instructor.ID, department.dept_name
from instructor, department
where instructor.dept_name = department.dept_name and department.budget > 95000;
```

输出结果由一个表组成，由两列（*ID*，*dept_name*）和五行（12121，Finance）、（45565，Comp. Sci.）、（10101，Comp. Sci.）、（83821，Comp. Sci.）、（76543，Finance）组成。

### 4.3 数据定义语言

```sql
-- 定义department表
create table department
		(dept_name  char(20),
		building  char(15),
		budget  numeric(12, 2));
```

---

## 5. 数据库设计

### 5.1 设计过程

1. 需求分析：制定出用户需求的**功能需求说明**（specification of functional requirement）。
2. **概念设计**（conceptual-design）：决定数据库中应该包括*哪些*属性，以及*如何*将这些属性*组织*到多个表中。后者主要有两种方法：一种是使用E-R模型，一种是引入一套算法（统称为*规范化*），这套算法将所有属性集作为输入，生成一组关系表。
3. **逻辑设计**（logical-design）：将高层的概念模式映射到要使用的数据库系统的实现数据模型上。
4. **物理设计**（physical-design）：指定数据库的物理设计。

### 5.2 实体 - 联系模型

数据库中实体通过**属性**（attribute）集合来描述，例如属性*dept_name*、*building*与*budget*组成了*department*实体集的属性。

**联系**（relationship）是几个实体之间的关联。例如*member*将以为教师和她所在的系关联在一起。同一类型的所有实体的集合称作**实体集**（entity set），同一类型的所有联系的集合称作**联系集**（relationship set）。

---

## 6. 数据存储和查询

### 6.1 存储管理器

存储管理器负责数据库中数据的存储、检索和更新。存储管理器负责与文件管理器进行交互，将各种DML语句翻译为底层文件系统命令。

存储管理部件包括：

- **权限及完整性管理器**（authorization and integrity manager）：检测是否满足完整性约束并检查试图访问数据的用户权限。
- **事务管理器**（transaction manager）：保证即使发生故障，数据库也保持在一致的（正确的）状态，并保证并发事务的执行不发生冲突。
- **文件管理器**（file manager）：管理磁盘存储的分配，管理用于表示存储信息的数据结构。
- **缓冲区管理器**（buffer manager）：将数据从磁盘取到内存上，并决定哪些数据应被缓冲存储在内存中。它使数据库能够处理比内存更大的数据。

存储管理器的数据结构（系统物理实现的一部分）：

- **数据文件**（data files）：存储数据库本身。
- **数据字典**（data dictionary）：存储关于数据库结构的元数据，尤其是数据库模式。
- **索引**（index）：提供对数据项的快速访问，提供了指向包含特定值的数据的指针。

### 6.2 查询处理器

查询处理组件包括：

- **DDL解释器**（DDL interpreter）：解释DDL语句并将这些定义记录在数据字典中。
- **DML编译器**（DML compiler）：将查询语言中的DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令。DML编译器还执行**查询优化**（query optimization），从几种选择中选出代价最小的一种。
- **查询执行引擎**（query evaluation engine）：执行DML编译器产生的低级指令。

---

## 7. 事务管理

**事务**（transaction）是数据库应用中完成单一逻辑功能的操作集合。每一个事务是既具**原子性**（atomicity）又具**一致性**（consistency）的单元。

保持原子性和**持久性**（durability）是**恢复管理器**（recovery manager）的职责，恢复管理器在事务执行失败等数据库发生故障时进行**故障恢复**（failure recovery）检测系统故障并将数据库恢复到故障发生之前的状态。

当多个事务同时对数据库进行更新时，**并发控制管理器**（concurrency-control manager）控制并发事务间的相互影响，防止数据的一致性被破坏。

**事务管理器**（transaction manager）包括恢复管理器和并发控制管理器。
